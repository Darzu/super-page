<!-- ================================================ -->
<!--                    ~ Welcome ~                   -->
<!-- ================================================ -->
<html>
<head>
<!-- ================================================ -->
<!--                      ~ CSS ~                     -->
<!-- ================================================ -->
<style type="text/css">
html {
  font-family: Arial, Helvetica, sans-serif;
  font-size: 12px;
}
p, ul, ol, dl, button, textarea, th {
  font-family: inherit;
}
th {
  font-weight: normal;
  text-align: left;
}
th, td {
  padding: 0.25rem;
  padding-right: 1rem;
}
body {
  background-color: #DDD;
  font-size: 1rem;
  margin:auto;
  position:relative;
}
#outer-column {
  width:50rem;/*changed once unleashed*/
  margin-left:auto;
  margin-right:auto;
  position: relative;
}
#inner-column {
  width:50rem;
  margin-left:auto;
  margin-right:auto;
  position: relative;
}
#page {
  background-color: #FFF;
  box-shadow: 0 0 1rem #666;
  padding:2rem;
}
.v-spacer {
  height:2rem;
  width:100%;
}
.center {
  display:block;
  margin-left:auto;
  margin-right:auto;
}
button {
  border-color: #AAA; 
  background-color: #DDD;
  border-style: solid;
  border-radius: .1667rem;
  font-size: 1.5rem;
  text-align: center;
  padding: 1rem;
  color:#AAA;
  cursor:pointer;
}
button:hover {
  background-color: #DFDFDF;
  color:#777;
  border-color:#777;
}
@-webkit-keyframes shake {
  0% { -webkit-transform: translate(1rem, 0.2rem) rotate(-5deg); }
  1% { -webkit-transform: translate(-3rem, 0) rotate(0deg); }
  2% { -webkit-transform: translate(1rem, -0.2rem) rotate(5deg); }
  3% { -webkit-transform: translate(-1.5rem, -0.2rem) rotate(-5deg); }
  4% { -webkit-transform: translate(3rem, 0) rotate(0deg); }
  5% { -webkit-transform: translate(-1rem, 0.2rem) rotate(5deg); }

  6% { -webkit-transform: translate(1rem, 0.2rem) rotate(-5deg); }
  7% { -webkit-transform: translate(-3rem, 0) rotate(0deg); }
  8% { -webkit-transform: translate(1rem, -0.2rem) rotate(5deg); }
  9% { -webkit-transform: translate(-1.5rem, -0.2rem) rotate(-5deg); }
  10% { -webkit-transform: translate(3rem, 0) rotate(0deg); }
  11% { -webkit-transform: translate(-1rem, 0.2rem) rotate(5deg); }

  12% { -webkit-transform: translate(0, 0) rotate(0deg); }
}
@keyframes shake {
  0% { transform: translate(1rem, 0.2rem) rotate(-5deg); }
  1% { transform: translate(-3rem, 0) rotate(0deg); }
  2% { transform: translate(1rem, -0.2rem) rotate(5deg); }
  3% { transform: translate(-1.5rem, -0.2rem) rotate(-5deg); }
  4% { transform: translate(3rem, 0) rotate(0deg); }
  5% { transform: translate(-1rem, 0.2rem) rotate(5deg); }

  6% { transform: translate(1rem, 0.2rem) rotate(-5deg); }
  7% { transform: translate(-3rem, 0) rotate(0deg); }
  8% { transform: translate(1rem, -0.2rem) rotate(5deg); }
  9% { transform: translate(-1.5rem, -0.2rem) rotate(-5deg); }
  10% { transform: translate(3rem, 0) rotate(0deg); }
  11% { transform: translate(-1rem, 0.2rem) rotate(5deg); }

  12% { transform: translate(0, 0) rotate(0deg); }
}
.shake:hover {
  -webkit-animation-name: shake;
  -webkit-animation-duration: 1.5s;
  -webkit-transform-origin:50% 50%;
  -webkit-animation-iteration-count: infinite;
  -webkit-animation-timing-function: linear;
  animation-name: shake;
  animation-duration: 1.5s;
  transform-origin:50% 50%;
  animation-iteration-count: infinite;
  animation-timing-function: linear;
}
.cfa {
  display: none;
  width:100%;
  min-height: 50rem;
  border:none;
}
canvas {
  pointer-events: none;
  position: absolute; 
  bottom: 0px; 
  left: 0px;
}
#under-canvas {
  z-index: -10;
}
#over-canvas {
  z-index: 10;
}
</style>
</head>
<!-- ================================================ -->
<!--                     ~ HTML ~                     -->
<!-- ================================================ -->
<body>
  <div id="outer-column">
    <div id="inner-column">
      <div class="v-spacer"></div>
      <div id="page">
        within
        <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
        mid
        <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
        within
      </div>
      <div class="v-spacer"></div>
      <button class="center shake" id="unleash-btn" onclick="DZ.unleash()">Unleash</button>
      <div class="v-spacer"></div>
    </div>
    <canvas id="under-canvas"></canvas>
    <canvas id="over-canvas"></canvas>
  </div>
<!-- ================================================ -->
<!--                    ~ Scripts ~                   -->
<!-- ================================================ -->
<script type="text/javascript">
console.log("hello world!")

window.DZ = {}

DZ.unleash = function() {
  var $unleashBtn = document.getElementById("unleash-btn");
  $unleashBtn.style.visibility = "hidden";

  DZ.loadSeedRandomJs();

  Math.seedrandom('dz');

  DZ.loadContextFreeJs()

  DZ.draw("lawn");
}

DZ.draw = function(cfa) {
  var bodyWidthRems = document.body.clientWidth / 12;

  var $outerColumn = document.getElementById("outer-column")

  $outerColumn.style.width= Math.max(bodyWidthRems, 75) + "rem";

  var $underCanvas = document.getElementById("under-canvas")
  $underCanvas.width = $outerColumn.clientWidth
  $underCanvas.height = $outerColumn.clientHeight

  var x = $underCanvas.width / 2;
  var y = $underCanvas.height;

  DZ.contextFree("cfa-"+cfa, "under-canvas", x, y)
}

DZ.gotoCfaEditor = function(cfa) {
  var $page = document.getElementById("page");

  //Empty page
  while ($page.hasChildNodes()) {
    $page.removeChild($page.lastChild);
  }

  var $cfa = document.getElementById("cfa-"+cfa);

  $page.appendChild($cfa);

  $cfa.style.display = "inline-block"

  var $redraw = document.createElement("button");

  $redraw.setAttribute("onclick", "DZ.draw('"+cfa+"')");

  $redraw.innerHTML = "Redraw"

  $page.appendChild($redraw);
}

DZ.loadSeedRandomJs = function() {
  !function(a,b,c,d,e,f,g,h,i){function j(a){var b,c=a.length,e=this,f=0,g=e.i=e.j=0,h=e.S=[];for(c||(a=[c++]);d>f;)h[f]=f++;for(f=0;d>f;f++)h[f]=h[g=r&g+a[f%c]+(b=h[f])],h[g]=b;(e.g=function(a){for(var b,c=0,f=e.i,g=e.j,h=e.S;a--;)b=h[f=r&f+1],c=c*d+h[r&(h[f]=h[g=r&g+b])+(h[g]=b)];return e.i=f,e.j=g,c})(d)}function k(a,b){var c,d=[],e=typeof a;if(b&&"object"==e)for(c in a)try{d.push(k(a[c],b-1))}catch(f){}return d.length?d:"string"==e?a:a+"\0"}function l(a,b){for(var c,d=a+"",e=0;e<d.length;)b[r&e]=r&(c^=19*b[r&e])+d.charCodeAt(e++);return n(b)}function m(c){try{return a.crypto.getRandomValues(c=new Uint8Array(d)),n(c)}catch(e){return[+new Date,a,(c=a.navigator)&&c.plugins,a.screen,n(b)]}}function n(a){return String.fromCharCode.apply(0,a)}var o=c.pow(d,e),p=c.pow(2,f),q=2*p,r=d-1,s=c["seed"+i]=function(a,f,g){var h=[];f=1==f?{entropy:!0}:f||{};var r=l(k(f.entropy?[a,n(b)]:null==a?m():a,3),h),s=new j(h);return l(n(s.S),b),(f.pass||g||function(a,b,d){return d?(c[i]=a,b):a})(function(){for(var a=s.g(e),b=o,c=0;p>a;)a=(a+c)*d,b*=d,c=s.g(1);for(;a>=q;)a/=2,b/=2,c>>>=1;return(a+c)/b},r,"global"in f?f.global:this==c)};l(c[i](),b),g&&g.exports?g.exports=s:h&&h.amd&&h(function(){return s})}(this,[],Math,256,6,52,"object"==typeof module&&module,"function"==typeof define&&define,"random");
}

DZ.loadContextFreeJs = function() {
  //Originally from: https://code.google.com/p/contextfree/source/browse/trunk/contextfree.js
  //Modified by DZ
  
  function min( list ){
    var min = { value: list[0], index: 0 };
    for( var i in list ) {
      if ( list[i] < min.value ){
        min.value = list[i];
        min.index = i;
      }
    }
    
    return min;
  }

  Object.forceExtend = function(dst, src) {
    for (var i in src) {
      try{ dst[i] = src[i] } catch(e) {}
    }
    return dst
  }
  // In case Object.extend isn't defined already, set it to Object.forceExtend.
  if (!Object.extend){
    Object.extend = Object.forceExtend
  }  

  // Used within a function to get an synonym'ed arguments value, or supply a default.
  // For example:
  //   var hue = getKeyValue( ["h", "hue"], 0, args );
  //   var x = getKeyValue( "x", 1, args );
  //
  function getKeyValue( possibleVariableNames, defaultValue, argList ){
    // We can either be getting a list of strings or a string. If we get a string,
    // we just convert it into a list containing that string.
    if( typeof(possibleVariableNames) == "string" ) {
      possibleVariableNames = [possibleVariableNames];
    }

    for( var i=0; i<=possibleVariableNames.length-1; i++) {
      var name = possibleVariableNames[i];
      if( typeof(argList[name]) != "undefined" ) {
        return argList[name];
      }
    }
    
    return defaultValue;
  }

  // indexOf
  if(!Array.indexOf){
    Array.prototype.indexOf = function(obj){
      for(var i=0; i<this.length; i++){
        if(this[i]==obj){
          return i;
        }
      }
      return -1;
    }
  }

  // hue, saturation, brightness, alpha
  // hue: [0,360) default 0
  // saturation: [0,1] default 0
  // brightness: [0,1] default 1
  // alpha: [0,1] default 1
  function hsl2rgb(h, s, l, a){ 
    if (h == 360){ h = 0;}

    //
    // based on C code from http://astronomy.swin.edu.au/~pbourke/colour/hsl/
    //

    while (h < 0){ h += 360; }
    while (h > 360){ h -= 360; }
    var r, g, b;
    if (h < 120){
      r = (120 - h) / 60;
      g = h / 60;
      b = 0;
    }else if (h < 240){
      r = 0;
      g = (240 - h) / 60;
      b = (h - 120) / 60;
    }else{
      r = (h - 240) / 60;
      g = 0;
      b = (360 - h) / 60;
    }

    r = Math.min(r, 1);
    g = Math.min(g, 1);
    b = Math.min(b, 1);

    r = 2 * s * r + (1 - s);
    g = 2 * s * g + (1 - s);
    b = 2 * s * b + (1 - s);

    if (l < 0.5){
      r = l * r;
      g = l * g;
      b = l * b;
    }else{
      r = (1 - l) * r + 2 * l - 1;
      g = (1 - l) * g + 2 * l - 1;
      b = (1 - l) * b + 2 * l - 1;
    }

    r = Math.ceil(r * 255);
    g = Math.ceil(g * 255);
    b = Math.ceil(b * 255);

    // Putting a semicolon at the end of an rgba definition
    // causes it to not work.
    return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")"

  }


  // TODO: String comments
  // TODO: Handle ordered arguments (i.e., square brakets)
  // TODO: Handle the | operator
  function Tokenizer( ){
    this._input = null;
    
    this._gStopChars = [" ", "{", "}", "\n", "\r", "\t"];
    
    this._tokenizeNext = function( pos ){
      var stops = [];
      var self = this;
      
      for( var i=0; i<this._gStopChars.length; i++ ) {
        var stopChar = this._gStopChars[i];
        var foundPos = self._input.indexOf( stopChar, pos );
        if( foundPos != -1 ){
          stops.push( foundPos + 1 )
        }     
      }
      
      var m = min(stops);
      var stopChar = this._gStopChars[ m.index ];
      var stopPos = m.value;
      
      if( typeof(m.value) == "undefined" ){ return null; }
      
      var token = this._input.substr(pos, stopPos-pos);
      
      // Remove whitespace characters as they can't be
      // tokens. Brackets can be tokens, so those don't
      // get removed.
      token = token.replace( /[ \n\r\t]/, "" );
      
      return { token: token, lastPos: stopPos }
    }
    
    this._tokenize = function(){
      // To make it easier to parse, we pad the brackets with spaces.
      this._input = this._input.replace( /([{}])/g, " $1"); 
      
      var tokens = [];
      
      var head = {lastPos: 0}
      while( 1==1 ){
        head = this._tokenizeNext( head.lastPos );
        
        if( head == null ){ break; }
        
        if( head.token ){
          tokens.push( head.token );
        }
        
      }
      
      return tokens;
    }
    
    this._load = function( inputField ) {
      var el = document.getElementById( inputField );
      this._input = el.value; 
    }
    
    this.tokenize = function( inputField ) {
      this._load( inputField );
      return this._tokenize();    
    }
  }


  // TODO: Handle ordered arguments
  // TODO: Handle the shape*[] syntax
  // TODO: Handle the | argument
  // TODO: Handle comments
  function Compiler() {
    this._keywords = ["startshape", "rule", "background"];
    this._compiled = {};
    this._state = null; 
    var compiler = this;
    
    this._generalState = function(){

      this.eat = function( token ){
        if( compiler._keywords.indexOf(token) != -1 ) {
          compiler._state = new compiler[ "_" + token + "State" ]();
        }
        else
        {
          console.log( token, " is not a general state token!" );
        }
      }
    }
    
    this._startshapeState = function() {
      this.eat = function( token ){
        compiler._compiled[ "startshape" ] = token;
        compiler._state = new compiler._generalState();
      }
    }

    this._backgroundState = function(){
      this._realState = new compiler._abstractArgumentState();
          
      this._realState.onDone = function( obj ){
        compiler._compiled[ "background" ] = obj;
        compiler._state = new compiler._generalState();     
      }
      
      // Inheritance from the the _abstractArgumentState.
      Object.extend( this, this._realState);
    }

    this._abstractArgumentState = function() {
      this._curKey = null;
      this._curValues = [];
      this._obj = {};
      
      this._flushKey = function() {
        if( this._curKey ){
          // If there is only one value for the key, we don't need to wrap
          // it in an array.
          if( this._curValues.length == 1 ){
            this._obj[ this._curKey ] = this._curValues[0];
          } else {
            this._obj[ this._curKey ] = this._curValues;
          }
        }
      }
      
      this.eat = function( token ) {      
        switch( token ){
          case "}":
            this._flushKey();
            this.onDone( this._obj );
          case "{":
            return;
        }
        
        // If it's a keyword name...
        if( token.match(/[a-z_]+/i) ) {
          this._flushKey();
          this._curKey = token;
          this._curValues = [];
        }
        // Otherwise it's a value (and hence a number)
        else {
          this._curValue = this._curValues.push( parseFloat(token) );
        }
      }
      
      // Override me!
      this.onDone = function( obj ){ }
    }


    this._ruleState = function(){
      // The first token is the name of the rule. After that comes
      // a "{" or the rule's weight.  
      this.eat = function( token ){
        var ruleName = token;
        
        // Create a blank rule if it doesn't aleady exist
        if( !compiler._compiled[ruleName] ){
          compiler._compiled[ruleName] = [];
        }
        compiler._state = new compiler._ruleWeightState( ruleName );      
      }
    }

    this._ruleWeightState = function( ruleName ){
      this._weight = 1;
      
      // You can either get the default weight (1) by not putting a weight after
      // a rule name, or you can define it after the name. For example:
      // rule tree { /* stuff */ }
      // rule tree .5 { /* stuff */ }   
      this.eat = function( token ) {
        if( token != "{" ){
          this._weight = parseFloat( token );
        } else {
          compiler._compiled[ruleName].push({ weight: this._weight, draw: [] })
          compiler._state = new compiler._ruleDrawState( ruleName );
        }
      }
    }
    
    // Here we actually get the shapes to be drawn. A shape consists of a name
    // and then an argument set.  
    this._ruleDrawState = function( ruleName ){     
        
      this.eat = function( token ){
        if( token == "}" ){
          compiler._state = new compiler._generalState();
          return;
        }
        
        var shapeName = token;
        
        compiler._state = new (function(){
          this._state = new compiler._abstractArgumentState();
          
          this._state.onDone = function( arguments ) {          
            var shape = { shape: shapeName };
            for( var key in arguments ){
              shape[key] = arguments[key];
            }
            
            // We are always adding to the lastest rule we've created.
            var last = compiler._compiled[ruleName].length - 1;
            compiler._compiled[ruleName][last].draw.push( shape )
            
            compiler._state = new compiler._ruleDrawState( ruleName );
          }
          
          // Inheritance from the abstract state.
          Object.extend( this, this._state);
        })()      
      }
    }
    
    this.compile = function( tokens ) {
      compiler._state = new compiler._generalState();
      tokens.reverse();
      while( tokens.length > 0 ){
        this._state.eat( tokens.pop() );
      }
      return compiler._compiled;
    };
  }


  function colorToRgba( color ){
    return hsl2rgb( color.h, color.s, color.b, color.a );
  }


  function adjustColor( color, adjustments ) {
    // See http://www.contextfreeart.org/mediawiki/index.php/Shape_adjustments
    var newColor = { h: color.h, s: color.s, b: color.b, a: color.a };
    
    // Add num to the drawing hue value, modulo 360 
    newColor.h += getKeyValue( ["h", "hue"], 0, adjustments );
    newColor.h %= 360;
    
    var adj = {};
    adj.s = getKeyValue( ["sat", "saturation"], 0, adjustments )
    adj.b = getKeyValue( ["b", "brightness"], 0, adjustments )
    adj.a = getKeyValue( ["a", "alpha"], 0, adjustments )
        
    // If adj<0 then change the drawing [blah] adj% toward 0.
    // If adj>0 then change the drawing [blah] adj% toward 1. 
    for( var key in adj ) {
      if( adj[key] > 0 ){
        newColor[key] += adj[key] * (1-color[key]);
      } else {
        newColor[key] += adj[key] * color[key];
      }
    }
        
    return newColor;  
  }


  function IdentityTransformation(){
    // 3x3 Matrix. This is the identity affine transformation.
    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
  }

  function toAffineTransformation( a, b, c, d, x, y ){
    return [ [a,b,x], [c,d,y], [0,0,1] ];
  }

  // Composes two transformations (i.e., by multiplying them).
  function compose(m1, m2) {
    var result = IdentityTransformation();

    for (var x = 0; x < 3; x++) {
      for (var y = 0; y < 3; y++) {
        var sum = 0;

        for (var z = 0; z < 3; z++) {
          sum += m1[x][z] * m2[z][y];
        }

        result[x][y] = sum;
      }
    }
    return result;
  }



  var Renderer = {
    canvas: null,
    ctx: null,
    width: null,
    height: null,
    
    compiled: null,
    _maxThreads: 30,
    
    queue: [],
    
    render: function( compiled, canvasId, pageX, pageY ) {
      Renderer.compiled = compiled;
      
      Renderer.canvas = document.getElementById( canvasId );
                          
      Renderer.ctx = Renderer.canvas.getContext("2d");
      
      Renderer.width = Renderer.canvas.width;
      Renderer.height = Renderer.canvas.height;
      
      Renderer._globalScale = 300;
      Renderer._rendering = false;
      
      Renderer.drawBackground();
      Renderer.setupEventHandlers();
      Renderer.draw(pageX, pageY);
      Renderer.tick();
    },
    
    tick: function(){
      if( Renderer.queue.length > 0 ){
        Renderer._rendering = true;
        var start = new Date();
        var concurrent = Math.min( Renderer.queue.length - 1, Renderer._maxThreads );
        
        for( var i=0; i<=concurrent; i++ ){
          Renderer.queue.shift().start();
        }
        var end = new Date();
        
        setTimeout( Renderer.tick, 2*(end-start) );
      }
      Renderer._rendering = false;
    },
    
    setupEventHandlers: function() {
      var handler = function(shapeName, event) {
        var foregroundColor = {h:0, s:0, b:0, a:1};
        var transform = toAffineTransformation( 1, 0, 0, 1,
                                                (event.pageX-Renderer.width/2) / Renderer._globalScale,
                                                (event.pageY-Renderer.height/2) / Renderer._globalScale );
        
        Renderer.drawRule( shapeName, transform, foregroundColor, 1 );

        if( !Renderer._rendering){
          Renderer.tick();
        }           
      }
      
      var mouseClick = getKeyValue( "MOUSECLICK", null, Renderer.compiled );
      if( mouseClick ){
        $(Renderer.canvas).click( function(e) {
          handler( "MOUSECLICK", e );
        });
      }
      
      var mouseMove = getKeyValue( "MOUSEMOVE", null, Renderer.compiled );
      if( mouseMove ){
        $(Renderer.canvas).mousemove( function(e) {
          handler( "MOUSEMOVE", e );
        });
      }
          
    },
    
    drawBackground: function() {
      if( Renderer.compiled.background ){
        var colorAdj = Renderer.compiled.background;
        var backgroundColor = {h:0, s:0, b:1, a:1};
        var c = adjustColor( backgroundColor, colorAdj );

        Renderer.ctx.fillStyle = colorToRgba( c );
        Renderer.ctx.fillRect( 0, 0, Renderer.width, Renderer.width );
      }
    },
    
    draw: function(pageX, pageY) {
      var transform;

      if (pageX !== null && pageY !== null) {
        transform = toAffineTransformation( 1, 0, 0, 1,
                                            (pageX-Renderer.width/2) / Renderer._globalScale,
                                            (pageY-Renderer.height/2) / Renderer._globalScale );
      } else {
        transform = IdentityTransformation();
      }
       

      var foregroundColor = {h:0, s:0, b:0, a:1};

      var ruleName = Renderer.compiled.startshape;
      var foregroundColor = {h:0, s:0, b:0, a:1};
      Renderer.drawRule( ruleName, transform, foregroundColor );
    },
    
    drawRule: function( ruleName, transform, color, priority ){
      // When things get too small, we can stop rendering.
      // Too small, in this case, means less than half a pixel.
      if( Math.abs(transform[0][1])*Renderer._globalScale < .5 && Math.abs(transform[1][1])*Renderer._globalScale < .5 ){
        return;
      }
      
      // Choose which rule to go with...
      var choices = Renderer.compiled[ruleName];
      
      var sum = 0;
      for( var i=0; i<choices.length; i++) {
        sum += choices[i].weight;
      }
      
      var r = Math.random() * sum;
      
      sum = 0;
      
      for( var i=0; i <= choices.length-1; i++) {
        sum += choices[i].weight;
        if( r <= sum ){
          var shape = choices[i];
          break;
        }
      }
      
      Renderer.drawShape( shape, transform, color, priority );
    },
    
    _draw: function( transform, drawFunc ) {    
      // If this is a browser that supports transform and setTransform
      // we can use that. It's nice and fast. Currently, the only
      // browser to support this is Firefox 3.
      if( Renderer.ctx.setTransform ) {
        Renderer.setTransform( transform );
        drawFunc( Renderer.ctx );
        return;
      }
      
      // If the browser does not support setTransform
      // then we do a lovely little hack that "just" stores the original
      // transform state (i.e., in the prestine Identity state);
      // deconvovles the desired transformation into
      // rotations, translations, and scales; perform those;
      // draw our shape; and then restore the Identity state. Phew!
      
      // If we are in FF2, or Safari... so do the hack :(
      var scale = toAffineTransformation( Renderer._globalScale, 0,                0,
                                          Renderer._globalScale, Renderer.width/2, Renderer.height/2 );
      var trans = compose( scale, transform );
      
      // We are currently at the global identity state for the transform.
      // Store it so that we can mess with it without worry.
      Renderer.ctx.save();
      
      if( Renderer.ctx.transform ){
        Renderer.ctx.transform( trans[0][0], trans[1][0], trans[0][1], trans[1][1], trans[0][2], trans[1][2] );
        drawFunc( Renderer.ctx );     
      } else
      {
        // summary: decompose a 2D matrix into translation, scaling, and rotation components
        //  The components should be applied in following order:
        //  [translate, rotate(angle2), scale, rotate(angle1)]
        var svd = svdTransform( trans );
      
        Renderer.ctx.translate( svd.dx, svd.dy );
        Renderer.ctx.rotate( svd.angle2 );
        Renderer.ctx.scale( svd.sx, svd.sy );
        Renderer.ctx.rotate( svd.angle1 );      
      }
      
      drawFunc( Renderer.ctx );
      
      // Restore the global transform state to the identity.
      Renderer.ctx.restore();

    },
    
    drawShape: function( shape, transform, color, priority ){
      for( i=0; i<shape.draw.length; i++){
        var item = shape.draw[i];

        var localTransform = Renderer.adjustTransform( item, transform );
        var localColor = adjustColor( color, item );
        
        switch( item.shape ){
          case "CIRCLE":          
            Renderer._draw( localTransform, function(ctx) {
              ctx.beginPath();
              ctx.fillStyle = colorToRgba( localColor );
              ctx.arc( 0, 0, .5, 0, 2*Math.PI, true )
              ctx.fill();
              ctx.closePath();            
            });
            break;
            
          case "SQUARE":
            Renderer._draw( localTransform, function(ctx) {
              ctx.beginPath();
              ctx.fillStyle = colorToRgba( localColor );
              ctx.fillRect(-.5, -.5, 1, 1);
              ctx.closePath();            
            });
            break;
          
          case "TRIANGLE":
            Renderer._draw( localTransform, function(ctx) {
              ctx.beginPath();
              var scale = 0.57735; // Scales the side of the triagle down to unit length.
              ctx.moveTo( 0, -scale );
              for( var i=1; i<=3; i++ ){
                ctx.lineTo( scale*Math.sin( i*2*Math.PI/3 ), -scale*Math.cos( i*2*Math.PI/3 ) );
              }
              ctx.fillStyle = colorToRgba( localColor );
              ctx.fill();
              ctx.closePath();            
            });
            break;
                      
          default:
            var threadedDraw = function(shape, transform, color){
              this.start = function(){
                Renderer.drawRule( shape, transform, color );
              }
            }
            
            var tD = new threadedDraw( item.shape, localTransform, localColor );
            
            if( priority == 1 ){ Renderer.queue.unshift(tD); }
            else{ Renderer.queue.push( tD ); }
                      
            break;
        }     
      }
    },
    
    setTransform: function( trans ){
      // Globally center and scale the transform (often the pictures are too small)
      Renderer.ctx.setTransform( Renderer._globalScale, 0, 0, Renderer._globalScale, Renderer.width/2, Renderer.height/2 );
      
      // Perform the actual transformation.
      Renderer.ctx.transform( trans[0][0], trans[1][0], trans[0][1], trans[1][1], trans[0][2], trans[1][2] );
    },
    

    adjustTransform: function( adjs, transform ){
      // Tranalsation
      var x = getKeyValue( "x", 0, adjs );
      var y = -getKeyValue( "y", 0, adjs );
          
      if( x != 0 || y != 0 ){
        var translate = toAffineTransformation(1, 0, 0, 1, x, y);
        transform = compose( transform, translate );
      }

      // Rotation
      var r = getKeyValue( ["r", "rotate"], null, adjs );
      if( r != null ){
        var cosTheta = Math.cos( -2*Math.PI * r/360 );
        var sinTheta = Math.sin( -2*Math.PI * r/360 );
        var rotate = toAffineTransformation( cosTheta, -sinTheta, sinTheta, cosTheta, 0, 0 );
        transform = compose( transform, rotate );
      }
          
      // Scaling
      var s = getKeyValue( ["s", "size"], 1, adjs );
      if( typeof(s) == "number" ){ s = [s,s]; }
      
      if( s != 1 ){
        var scale = toAffineTransformation(s[0], 0, 0, s[1], 0, 0 );
        transform = compose( transform, scale );
      }           
          
      // Flip around a line through the origin;
      var f = getKeyValue( ["f", "flip"], null, adjs );
      if( f != null ){
        // Flip 0 means to flip along the X axis. Flip 90 means to flip along the Y axis.
        // That's why the flip vector (vX, vY) is Pi/2 radians further along than expected. 
        vX = Math.cos( -2*Math.PI * f/360 );
        vY = Math.sin( -2*Math.PI * f/360 );
        norm = 1/(vX*vX + vY*vY);
        var flip = toAffineTransformation((vX*vX-vY*vY)/norm, 2*vX*vY/norm, 2*vX*vY/norm, (vY*vY-vX*vX)/norm, 0, 0);
        transform = compose( transform, flip );
      }
      
      return transform;
      
    }   
  }

  function contextFree( textId, canvasId, pageX, pageY ) {
    var t = new Tokenizer();
    var tokens = t.tokenize( textId );

    var c = new Compiler();
    var compiled = c.compile( tokens );

    var r = Renderer;
    Renderer.queue = [];
    r.render( compiled, canvasId, pageX, pageY );
  }

  svdTransform  = (function(){
    //   Copyright (c) 2004-2005, The Dojo Foundation
    //   All Rights Reserved
    var m = {}
    m.Matrix2D = function(arg){
      // summary: a 2D matrix object
      // description: Normalizes a 2D matrix-like object. If arrays is passed,
      //    all objects of the array are normalized and multiplied sequentially.
      // arg: Object
      //    a 2D matrix-like object, a number, or an array of such objects
      if(arg){
        if(typeof arg == "number"){
          this.xx = this.yy = arg;
        }else if(arg instanceof Array){
          if(arg.length > 0){
            var matrix = m.normalize(arg[0]);
            // combine matrices
            for(var i = 1; i < arg.length; ++i){
              var l = matrix, r = m.normalize(arg[i]);
              matrix = new m.Matrix2D();
              matrix.xx = l.xx * r.xx + l.xy * r.yx;
              matrix.xy = l.xx * r.xy + l.xy * r.yy;
              matrix.yx = l.yx * r.xx + l.yy * r.yx;
              matrix.yy = l.yx * r.xy + l.yy * r.yy;
              matrix.dx = l.xx * r.dx + l.xy * r.dy + l.dx;
              matrix.dy = l.yx * r.dx + l.yy * r.dy + l.dy;
            }
            Object.extend(this, matrix);
          }
        }else{
          Object.extend(this, arg);
        }
      }
    }
    // ensure matrix 2D conformance
    m.normalize = function(matrix){
        // summary: converts an object to a matrix, if necessary
        // description: Converts any 2D matrix-like object or an array of
        //    such objects to a valid dojox.gfx.matrix.Matrix2D object.
        // matrix: Object: an object, which is converted to a matrix, if necessary
        return (matrix instanceof m.Matrix2D) ? matrix : new m.Matrix2D(matrix); // dojox.gfx.matrix.Matrix2D
    }
    m.multiply = function(matrix){
      // summary: combines matrices by multiplying them sequentially in the given order
      // matrix: dojox.gfx.matrix.Matrix2D...: a 2D matrix-like object, 
      //    all subsequent arguments are matrix-like objects too
      var M = m.normalize(matrix);
      // combine matrices
      for(var i = 1; i < arguments.length; ++i){
        var l = M, r = m.normalize(arguments[i]);
        M = new m.Matrix2D();
        M.xx = l.xx * r.xx + l.xy * r.yx;
        M.xy = l.xx * r.xy + l.xy * r.yy;
        M.yx = l.yx * r.xx + l.yy * r.yx;
        M.yy = l.yx * r.xy + l.yy * r.yy;
        M.dx = l.xx * r.dx + l.xy * r.dy + l.dx;
        M.dy = l.yx * r.dx + l.yy * r.dy + l.dy;
      }
      return M; // dojox.gfx.matrix.Matrix2D
    }
    m.invert = function(matrix) {
      var M = m.normalize(matrix),
        D = M.xx * M.yy - M.xy * M.yx,
        M = new m.Matrix2D({
          xx: M.yy/D, xy: -M.xy/D, 
          yx: -M.yx/D, yy: M.xx/D, 
          dx: (M.xy * M.dy - M.yy * M.dx) / D, 
          dy: (M.yx * M.dx - M.xx * M.dy) / D
        });
      return M; // dojox.gfx.matrix.Matrix2D
    }
    // the default (identity) matrix, which is used to fill in missing values
    Object.extend(m.Matrix2D, {xx: 1, xy: 0, yx: 0, yy: 1, dx: 0, dy: 0});

    var eq = function(/* Number */ a, /* Number */ b){
      // summary: compare two FP numbers for equality
      return Math.abs(a - b) <= 1e-6 * (Math.abs(a) + Math.abs(b)); // Boolean
    };
    
    var calcFromValues = function(/* Number */ s1, /* Number */ s2){
      // summary: uses two close FP values to approximate the result
      if(!isFinite(s1)){
        return s2;  // Number
      }else if(!isFinite(s2)){
        return s1;  // Number
      }
      return (s1 + s2) / 2; // Number
    };
    
    var transpose = function(/* dojox.gfx.matrix.Matrix2D */ matrix){
      // matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix-like object
      var M = new m.Matrix2D(matrix);
      return Object.extend(M, {dx: 0, dy: 0, xy: M.yx, yx: M.xy}); // dojox.gfx.matrix.Matrix2D
    };
    
    var scaleSign = function(/* dojox.gfx.matrix.Matrix2D */ matrix){
      return (matrix.xx * matrix.yy < 0 || matrix.xy * matrix.yx > 0) ? -1 : 1; // Number
    };
    
    var eigenvalueDecomposition = function(/* dojox.gfx.matrix.Matrix2D */ matrix){
      // matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix-like object
      var M = m.normalize(matrix),
        b = -M.xx - M.yy,
        c = M.xx * M.yy - M.xy * M.yx,
        d = Math.sqrt(b * b - 4 * c),
        l1 = -(b + (b < 0 ? -d : d)) / 2,
        l2 = c / l1,
        vx1 = M.xy / (l1 - M.xx), vy1 = 1,
        vx2 = M.xy / (l2 - M.xx), vy2 = 1;
      if(eq(l1, l2)){
        vx1 = 1, vy1 = 0, vx2 = 0, vy2 = 1;
      }
      if(!isFinite(vx1)){
        vx1 = 1, vy1 = (l1 - M.xx) / M.xy;
        if(!isFinite(vy1)){
          vx1 = (l1 - M.yy) / M.yx, vy1 = 1;
          if(!isFinite(vx1)){
            vx1 = 1, vy1 = M.yx / (l1 - M.yy);
          }
        }
      }
      if(!isFinite(vx2)){
        vx2 = 1, vy2 = (l2 - M.xx) / M.xy;
        if(!isFinite(vy2)){
          vx2 = (l2 - M.yy) / M.yx, vy2 = 1;
          if(!isFinite(vx2)){
            vx2 = 1, vy2 = M.yx / (l2 - M.yy);
          }
        }
      }
      var d1 = Math.sqrt(vx1 * vx1 + vy1 * vy1),
        d2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);
      if(isNaN(vx1 /= d1)){ vx1 = 0; }
      if(isNaN(vy1 /= d1)){ vy1 = 0; }
      if(isNaN(vx2 /= d2)){ vx2 = 0; }
      if(isNaN(vy2 /= d2)){ vy2 = 0; }
      return {  // Object
        value1: l1,
        value2: l2,
        vector1: {x: vx1, y: vy1},
        vector2: {x: vx2, y: vy2}
      };
    };
    
    var decomposeSR = function(/* dojox.gfx.matrix.Matrix2D */ M, /* Object */ result){
      // summary: decomposes a matrix into [scale, rotate]; no checks are done.
      var sign = scaleSign(M),
        a = result.angle1 = (Math.atan2(M.yx, M.yy) + Math.atan2(-sign * M.xy, sign * M.xx)) / 2,
        cos = Math.cos(a), sin = Math.sin(a);
      result.sx = calcFromValues(M.xx / cos, -M.xy / sin);
      result.sy = calcFromValues(M.yy / cos, M.yx / sin);
      return result;  // Object
    };
    
    var decomposeRS = function(/* dojox.gfx.matrix.Matrix2D */ M, /* Object */ result){
      // summary: decomposes a matrix into [rotate, scale]; no checks are done
      var sign = scaleSign(M),
        a = result.angle2 = (Math.atan2(sign * M.yx, sign * M.xx) + Math.atan2(-M.xy, M.yy)) / 2,
        cos = Math.cos(a), sin = Math.sin(a);
      result.sx = calcFromValues(M.xx / cos, M.yx / sin);
      result.sy = calcFromValues(M.yy / cos, -M.xy / sin);
      return result;  // Object
    };
    
    return function(transform){
      // summary: decompose a 2D matrix into translation, scaling, and rotation components
      // description: this function decompose a matrix into four logical components: 
      //  translation, rotation, scaling, and one more rotation using SVD.
      //  The components should be applied in following order:
      //  | [translate, rotate(angle2), scale, rotate(angle1)]
      // matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix-like object
      
      // First convert the transform into a Dojo-style matrix;
      var matrix = {
        xx: transform[0][0],
        xy: transform[0][1],
        yx: transform[1][0],
        yy: transform[1][1],
        dx: transform[0][2],
        dy: transform[1][2]
      };
      
      var M = m.normalize(matrix), 
        result = {dx: M.dx, dy: M.dy, sx: 1, sy: 1, angle1: 0, angle2: 0};
      // detect case: [scale]
      if(eq(M.xy, 0) && eq(M.yx, 0)){
        return Object.extend(result, {sx: M.xx, sy: M.yy});  // Object
      }
      // detect case: [scale, rotate]
      if(eq(M.xx * M.yx, -M.xy * M.yy)){
        return decomposeSR(M, result);  // Object
      }
      // detect case: [rotate, scale]
      if(eq(M.xx * M.xy, -M.yx * M.yy)){
        return decomposeRS(M, result);  // Object
      }
      // do SVD
      var MT = transpose(M),
        u  = eigenvalueDecomposition([M, MT]),
        v  = eigenvalueDecomposition([MT, M]),
        U  = new m.Matrix2D({xx: u.vector1.x, xy: u.vector2.x, yx: u.vector1.y, yy: u.vector2.y}),
        VT = new m.Matrix2D({xx: v.vector1.x, xy: v.vector1.y, yx: v.vector2.x, yy: v.vector2.y}),
        S = new m.Matrix2D([m.invert(U), M, m.invert(VT)]);
      decomposeSR(VT, result);
      S.xx *= result.sx;
      S.yy *= result.sy;
      decomposeRS(U, result);
      S.xx *= result.sx;
      S.yy *= result.sy;
      return Object.extend(result, {sx: S.xx, sy: S.yy});  // Object
    };
  })()

  //DZ exports
  DZ.contextFree = contextFree;
}
</script>
<!-- ================================================ -->
<!--                      ~ CFA ~                     -->
<!-- ================================================ -->
<textarea class="cfa" id="cfa-tree">
startshape family

rule family { 
TREE {s 0.2 r 45} 

}

rule TREE  10 {
TRIANGLE { s .30 1}

TREE { y 0.4 size 0.945 b .02 r 10}
}

rule TREE  10 {
TRIANGLE { size 0.30 1.5  hue 90 sat .5}

TREE { y 0.4 size 0.945 r -10 b .01}
}

rule TREE 2.5{
ZWEIG {}
}

rule ZWEIG{
ZWEIG_LINKS  {}
ZWEIG_RECHTS {}
}

rule ZWEIG_LINKS 3{
TREE {r 15 s .98}
}
rule ZWEIG_LINKS{
TREE {r 10 s .99}
}


rule ZWEIG_RECHTS 3{
TREE {r -5 s .98}
}
rule ZWEIG_RECHTS{
TREE {r -10 s .99 }
}
</textarea>
<textarea class="cfa" id="cfa-lawn">
startshape start

rule start{
startGrass {s 0.25 hue 109  sat .58 b .47}

}

rule startGrass{
rowsL { r -90}
rowsR { r 90}

}

rule rowsL {
rowL { y -0.1 b -0.3 }
rowL { y -0.13 b 0.1 }
rowL { y -0.16 b -0.1 }
rowL { y -0.2 b 0.2 }
rowL { y -0.23 b -0.2 }
rowL { y -0.26  }
 
}

rule rowL {
 rowL { y 0.1888 }

 grass { s .03   r  135  } 
}

rule rowsR {
rowR { y 0.1 b -0.3 }
rowR { y 0.13 b 0.1 }
rowR { y 0.16 b -0.1 }
rowR { y 0.2 b 0.2 }
rowR { y 0.23 b -0.2 }
rowR { y 0.26  }
 
}

rule rowR {
 rowR { y 0.32 }

 grass { s .03   r  315  } 
}

rule grass 200 {
 SQUARE { r 45 }
 grass { x 0.5 y 0.5 r 1 b 0.005 }

}

rule grass  200 {
 SQUARE { r 45 }
 grass { x 0.5 y 0.5 r -1 b 0.005 }

}

rule grass 1 {
}

</textarea>
</body>
</html>